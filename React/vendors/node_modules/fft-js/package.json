{
  "_args": [
    [
      {
        "raw": "node-fft",
        "scope": null,
        "escapedName": "node-fft",
        "name": null,
        "rawSpec": "node-fft",
        "spec": "/Users/rpd-air/Documents/Galvanize/Projects/q4/play-pitch-precision/vendors/node-fft",
        "type": "directory"
      },
      "/Users/rpd-air/Documents/Galvanize/Projects/q4/play-pitch-precision/vendors"
    ]
  ],
  "_from": "node-fft",
  "_id": "fft-js@0.0.10",
  "_inCache": true,
  "_location": "/fft-js",
  "_phantomChildren": {},
  "_requested": {
    "raw": "node-fft",
    "scope": null,
    "escapedName": "node-fft",
    "name": null,
    "rawSpec": "node-fft",
    "spec": "/Users/rpd-air/Documents/Galvanize/Projects/q4/play-pitch-precision/vendors/node-fft",
    "type": "directory"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "file:node-fft",
  "_shasum": "50d9e4b87d320c4e638158808bf330c0a7da386b",
  "_shrinkwrap": null,
  "_spec": "node-fft",
  "_where": "/Users/rpd-air/Documents/Galvanize/Projects/q4/play-pitch-precision/vendors",
  "bugs": {
    "url": "https://github.com/vail-systems/node-fft/issues"
  },
  "contributors": [
    {
      "name": "Joshua Jung",
      "email": "joshua.p.jung@gmail.com",
      "url": "http://www.joshjung.com"
    },
    {
      "name": "Ben Bryan",
      "email": "bbryan@vailsys.com"
    }
  ],
  "dependencies": {
    "bit-twiddle": "~1.0.2",
    "commander": "~2.7.1"
  },
  "description": "Simple pure Javascript implementation of the Cooley-Tukey algorithm. Note: fft-js was chosen as the name since a lot of the FFT implementations on NPM at the time this was published were wrappers for Ruby or C.",
  "devDependencies": {},
  "engines": {
    "node": ">=0.12.0"
  },
  "files": [
    "index.js",
    "fft.js",
    "src",
    "test"
  ],
  "gitHead": "ec97814e42a4078d32f56a519573d2c42188e790",
  "homepage": "https://github.com/vail-systems/node-fft",
  "keywords": [
    "fft",
    "dft",
    "fast",
    "discrete",
    "fourier",
    "transform",
    "audio",
    "speech",
    "cooley",
    "tukey"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "fft-js",
  "optionalDependencies": {},
  "readme": "# fft-js\nPure Node.js implementation of the Fast Fourier Transform (Cooley-Tukey Method).\n\nNote: normally inclusion of 'js' in the package name is discouraged. However many of the FFT implementations on NPM at the time this was written are wrappers for other languages like Ruby or C. We wanted to write our own, unoptimized implementation in pure Javascript as an educational tool. As a result it is called fft-js.\n\n# Simple Example\n\n    var fft = require('fft-js').fft,\n        signal = [1,0,1,0];\n\n    var phasors = fft(signal);\n\n    console.log(phasors);\n\n# Frequency/Magnitude Example\n\n    var fft = require('fft-js').fft,\n        fftUtil = require('fft-js').util,\n        signal = [1,0,1,0];\n\n    var phasors= fft(signal);\n\n    var frequencies = fftUtil.fftFreq(phasors, 8000), // Sample rate and coef is just used for length, and frequency step\n        magnitudes = fftUtil.fftMag(phasors); \n\n    var both = frequencies.map(function (f, ix) {\n        return {frequency: f, magnitude: magnitudes[ix]};\n    });\n\n    console.log(both);\n\n# Calculate IFFT of given phasors\n    \n    var ifft = require('fft-js').ifft;\n\n    var phasors=[[1,0], [0,0], [1,0], [0,0]];\n\n    var signal=ifft(phasors);\n\n    console.log(signal);\n\n#Calculate fft, modify phasors and calculate ifft\n\n    var fft = require('fft-js').fft;\n    var ifft = require('fft-js').ifft;\n\n    var signal=[1,0,1,0];\n\n    var phasors=fft(signal);\n\n    console.log(phasors);\n\n    phasors[2][0]=0;\n\n    var signal2=ifft(phasors);\n\n    console.log(signal2);\n\n    \n# Brute force O(n^2) DFT Example\n\nThe DFT (Discrete Fourier Transform) is an unoptimized Fourier Transform for discrete data. In this project it is primarily a teaching tool, and is used to test the FFT.\n\n    var dft = require('fft-js').dft,\n        signal = [1,0,1,0];\n    \n    var phasors = dft(signal);\n    \n    console.log(phasors);\n\n# In-place FFT Example\n\nThe in-place FFT implementation generates the FFT in-place, overwriting the original input vector. This is useful for minimizing new memory allocations required for the recursive version.\n\n    var fftInPlace = require('fft-js').fftInPlace,\n        signal = [1, 0, 1, 0];\n        \n    fftInPlace(signal);\n    \n    console.log(signal); //We have overwritten the original vector here with the FFT output.\n\n# Command Line\n\nFor testing, you can run from the command line. Input is assumed to be from standard input and contain\na comma-delimited list of real numbers.\n\nCommand:\n    node fft.js -s 44100 test/signal8.js\n\nConsole:\n\n    Signal:  [ 1, 1, 1, 1, 0, 0, 0, 0 ]\n\n    FFT:  [ [ 4, 0 ],\n    [ 1, -2.414213562373095 ],\n    [ 0, 0 ],\n    [ 1, -0.4142135623730949 ],\n    [ 0, 0 ],\n    [ 0.9999999999999999, 0.4142135623730949 ],\n    [ 0, 0 ],\n    [ 0.9999999999999997, 2.414213562373095 ] ]\n\n    FFT Magnitudes:  [ 4, 2.613125929752753, 0, 1.0823922002923938 ] //We only see the first 4, because the 2nd 4 are the Nyquist frequency (discarded for aliasing), and then the mirror image negative frequencies.\n\n    FFT Frequencies:  [ 0, 5512.5, 11025, 16537.5 ]\n\n# Testing\n\nSee `test/test.js`. Using Mocha:\n\n    mocha\n\nOutput:\n\n    FFT (Cooley-Tukey)\n    1,0,1,0\n      ✓ Should properly compute [1,0,1,0]\n    1,0,1,0,2,0,2,0\n      ✓ Should properly compute [1,0,1,0,2,0,2,0]\n    \n    FFT (in-place Cooley-Tukey)\n    1,0,1,0\n      ✓ Should properly compute [1,0,1,0]\n    1,0,1,0,2,0,2,0\n      ✓ Should properly compute [1,0,1,0,2,0,2,0]\n\n    IFFT (Cooley-Tukey)\n    1,0,1,0\n      ✓ Should properly compute [1,0,1,0]\n    1,0,1,0,2,0,2,0\n      ✓ Should properly compute [1,0,1,0,2,0,2,0]\n    \n    DFT O(n^2) Brute Force\n    1,0,1,0\n      ✓ Should properly compute [1, 0, 1, 0]\n    \n    Compare FFT to DFT\n    randomSignal FFT\n      ✓ Should compute randomSignal\n    randomSignal in-place FFT\n      ✓ Should compute randomSignal\n    randomSignal DFT\n      ✓ Should compute randomSignal\n    randomSignal FFT and DFT\n      ✓ Should compute same output\n    randomSignal in-place FFT and DFT\n      ✓ Should compute same output\n    \n    \n    12 passing (20ms)\n\n# License \n\nThe MIT License (MIT)\n\nCopyright (c) 2015 Vail Systems\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vail-systems/node-fft.git"
  },
  "scripts": {
    "test": "mocha"
  },
  "version": "0.0.10"
}
